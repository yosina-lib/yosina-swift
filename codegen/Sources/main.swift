import Foundation

enum CodegenError: Error {
    case fileNotFound(String)
    case invalidJSON(String)
    case invalidUnicodeString(String)
    case writeFailed(String)
}

enum StringOrArray: Codable {
    case string(String)
    case array([String])

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(String.self) {
            self = .string(value)
        } else if let value = try? container.decode([String].self) {
            self = .array(value)
        } else {
            throw DecodingError.typeMismatch(
                StringOrArray.self,
                DecodingError.Context(
                    codingPath: decoder.codingPath,
                    debugDescription: "Expected String or [String]"
                )
            )
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .string(value):
            try container.encode(value)
        case let .array(value):
            try container.encode(value)
        }
    }

    var asArray: [String]? {
        switch self {
        case let .string(value):
            return [value]
        case let .array(value):
            return value
        }
    }
}

struct CodeGenerator {
    let dataPath: String
    let outputPath: String

    init() {
        let currentPath = FileManager.default.currentDirectoryPath
        dataPath = (currentPath as NSString).appendingPathComponent("../../data")
        outputPath = (currentPath as NSString).appendingPathComponent(
            "../Sources/Yosina/Transliterators")
    }

    func run() throws {
        try FileManager.default.createDirectory(
            atPath: outputPath, withIntermediateDirectories: true
        )

        try generateSpacesTransliterator()
        try generateHyphensTransliterator()
        try generateRadicalsTransliterator()
        try generateMathematicalAlphanumericsTransliterator()
        try generateIdeographicAnnotationsTransliterator()
        try generateKanjiOldNewTransliterator()
        try generateCombinedTransliterator()
        try generateCircledOrSquaredTransliterator()
        try generateIvsSvsBaseTransliterator()

        print("Code generation completed successfully!")
    }

    func loadJSONData<T: Decodable>(_ filename: String, as type: T.Type) throws -> T {
        let path = (dataPath as NSString).appendingPathComponent(filename)
        guard let data = FileManager.default.contents(atPath: path) else {
            throw CodegenError.fileNotFound(filename)
        }

        do {
            return try JSONDecoder().decode(type, from: data)
        } catch {
            throw CodegenError.invalidJSON("\(filename): \(error)")
        }
    }

    func loadSimpleJSONData(_ filename: String) throws -> [(Character, Character?)] {
        let data = try loadJSONData(filename, as: [String: String?].self)
        let sortedPairs = data.sorted { $0.key < $1.key }
        return try sortedPairs.compactMap { key, value -> (Character, Character?)? in
            let key = try unicodeToChar(key)
            if let value = value {
                return try (key, unicodeToChar(value))
            } else {
                return (key, nil)
            }
        }
    }

    func writeFile(_ filename: String, content: String) throws {
        let path = (outputPath as NSString).appendingPathComponent(filename)
        do {
            try content.write(toFile: path, atomically: true, encoding: .utf8)
        } catch {
            throw CodegenError.writeFailed("\(filename): \(error)")
        }
    }

    func fileHeader() -> String {
        """
        // This file is automatically generated. Do not edit.
        // Generated on: \(Date())

        import Foundation

        """
    }

    func generateSimpleMappingInner(className: String, mappings: [(Character, Character?)]) throws {
        // Check if we need to use binary search due to duplicate characters
        var seenChars = Set<Character>()
        var hasDuplicates = false
        for (char, _) in mappings {
            if seenChars.contains(char) {
                hasDuplicates = true
                break
            }
            seenChars.insert(char)
        }

        var content = fileHeader()

        if hasDuplicates {
            // Use sorted array with binary search
            content += """
            public struct \(className): Transliterator {
                // Using sorted array to handle potential Swift Character equality issues
                private static let sortedMappings: [(Character, Character?)] = [
            """

            for (key, value) in mappings {
                content += "\n        (\(escape(key)), \(escape(value))),"
            }

            content += """

                ]

                public init() {}

                public func transliterate<S: Sequence>(_ chars: S) -> [TransliteratorChar] where S.Element == TransliteratorChar {
                    var result: [TransliteratorChar] = []
                    var offset = 0

                    for char in chars {
                        if let charValue = char.value {
                            // Binary search for the character
                            let index = Self.sortedMappings.binarySearch { $0.0 < charValue }

                            // Check if we found an exact match
                            if index < Self.sortedMappings.count && Self.sortedMappings[index].0 == charValue {
                                if let replacement = Self.sortedMappings[index].1 {
                                    let newChar = TransliteratorChar(value: replacement, offset: offset, source: char)
                                    offset += replacement.utf8.count
                                    result.append(newChar)
                                    continue
                                }
                                // If replacement is nil, skip this character (don't append it)
                                continue
                            }
                        }

                        // No mapping found, keep the original character
                        let char = char.withOffset(offset)
                        offset += char.utf8Count
                        result.append(char)
                    }

                    return result
                }
            }

            extension Array {
                fileprivate func binarySearch(by predicate: (Element) -> Bool) -> Index {
                    var low = startIndex
                    var high = endIndex

                    while low < high {
                        let mid = index(low, offsetBy: distance(from: low, to: high) / 2)
                        if predicate(self[mid]) {
                            low = index(after: mid)
                        } else {
                            high = mid
                        }
                    }

                    return low
                }
            }
            """
        } else {
            // Use dictionary as before (no duplicates)
            content += """
            public struct \(className): Transliterator {
                private static let mapping: [Character: Character?] = [
            """

            for (key, value) in mappings {
                content += "\n        \(escape(key)): \(escape(value)),"
            }

            content += """
                ]

                public init() {}

                public func transliterate<S: Sequence>(_ chars: S) -> [TransliteratorChar] where S.Element == TransliteratorChar {
                    var result: [TransliteratorChar] = []
                    var offset = 0

                    for char in chars {
                        if let charValue = char.value, let replacement = Self.mapping[charValue] {
                            if let replacement = replacement {
                                let char = TransliteratorChar(value: replacement, offset: offset, source: char)
                                offset += replacement.utf8.count
                                result.append(char)
                            }
                        } else {
                            let char = char.withOffset(offset)
                            offset += char.utf8Count
                            result.append(char)
                        }
                    }

                    return result
                }
            }
            """
        }

        try writeFile("\(className).swift", content: content)
        print("Generated \(className).swift")
    }
}

// MARK: - Hyphens Transliterator

extension CodeGenerator {
    struct HyphenData: Codable {
        let code: String
        let name: String
        let ascii: [String]?
        let jisx0201: [String]?
        let jisx0208_1978: [String]? // Maps to jisx0208_90
        let jisx0208_1978_windows: [String]? // Maps to jisx0208_90_windows
        let jisx0208_verbatim: StringOrArray? // Can be string or null in JSON

        enum CodingKeys: String, CodingKey {
            case code, name, ascii, jisx0201
            case jisx0208_1978 = "jisx0208-1978"
            case jisx0208_1978_windows = "jisx0208-1978-windows"
            case jisx0208_verbatim = "jisx0208-verbatim"
        }
    }

    func generateHyphensTransliterator() throws {
        let dataArray = try loadJSONData("hyphens.json", as: [HyphenData].self)

        var content = fileHeader()
        content += """
        public struct HyphensTransliterator: Transliterator {
            public enum Precedence: String, CaseIterable {
                case ascii
                case jisx0201
                case jisx0208_90
                case jisx0208_90_windows
                case jisx0208_verbatim
            }

            public struct Options {
                public var precedence: [Precedence] = [.jisx0208_90]

                public init() {}
            }

            private struct HyphensRecord {
                let ascii: String?
                let jisx0201: String?
                let jisx0208_90: String?
                let jisx0208_90_windows: String?
                let jisx0208_verbatim: String?
            }

            private let options: Options
            private static let mapping: [Character: HyphensRecord] = [
        """

        for item in dataArray {
            let fromChar = try unicodeToChar(item.code)

            // Handle multi-character replacements
            let ascii = item.ascii != nil ? try unicodeTupleToString(item.ascii!) : nil
            let jisx0201 = item.jisx0201 != nil ? try unicodeTupleToString(item.jisx0201!) : nil
            let jisx0208_90 =
                item.jisx0208_1978 != nil ? try unicodeTupleToString(item.jisx0208_1978!) : nil
            let jisx0208_90_windows =
                item.jisx0208_1978_windows != nil
                    ? try unicodeTupleToString(item.jisx0208_1978_windows!) : nil
            let jisx0208_verbatim =
                item.jisx0208_verbatim != nil
                    ? try unicodeTupleToString(item.jisx0208_verbatim!) : nil

            content += "\n        \(escape(String(fromChar))): HyphensRecord("
            content += "\n            ascii: " + escape(ascii) + ","
            content += "\n            jisx0201: " + escape(jisx0201) + ","
            content += "\n            jisx0208_90: " + escape(jisx0208_90) + ","
            content += "\n            jisx0208_90_windows: " + escape(jisx0208_90_windows) + ","
            content += "\n            jisx0208_verbatim: " + escape(jisx0208_verbatim)
            content += "\n        ),"
        }

        content += """

            ]

            public init(options: Options = Options()) {
                self.options = options
            }

            public func transliterate<S: Sequence>(_ chars: S) -> [TransliteratorChar] where S.Element == TransliteratorChar {
                var result: [TransliteratorChar] = []
                var offset = 0

                for char in chars {
                    if let charValue = char.value, let record = Self.mapping[charValue] {
                        let replacement = getReplacement(for: record)
                        if let replacement = replacement, replacement != String(charValue) {
                            // Handle multi-character replacements
                            for replacementChar in replacement {
                                let c = TransliteratorChar(
                                    value: replacementChar,
                                    offset: offset,
                                    source: char
                                )
                                result.append(c)
                                offset += replacementChar.utf8.count
                            }
                            continue
                        }
                    }
                    let char = char.withOffset(offset)
                    offset += char.utf8Count
                    result.append(char)
                }

                return result
            }

            private func getReplacement(for record: HyphensRecord) -> String? {
                for prec in options.precedence {
                    switch prec {
                    case .ascii:
                        if let replacement = record.ascii { return replacement }
                    case .jisx0201:
                        if let replacement = record.jisx0201 { return replacement }
                    case .jisx0208_90:
                        if let replacement = record.jisx0208_90 { return replacement }
                    case .jisx0208_90_windows:
                        if let replacement = record.jisx0208_90_windows { return replacement }
                    case .jisx0208_verbatim:
                        if let replacement = record.jisx0208_verbatim { return replacement }
                    }
                }
                return nil
            }
        }
        """

        try writeFile("HyphensTransliterator.swift", content: content)
        print("Generated HyphensTransliterator.swift")
    }
}

// MARK: - Other Transliterators (simplified for brevity)

extension CodeGenerator {
    func generateSpacesTransliterator() throws {
        let data = try loadSimpleJSONData("spaces.json")
        try generateSimpleMappingInner(className: "SpacesTransliterator", mappings: data)
    }

    func generateRadicalsTransliterator() throws {
        let data = try loadSimpleJSONData("radicals.json")
        try generateSimpleMappingInner(className: "RadicalsTransliterator", mappings: data)
    }

    func generateMathematicalAlphanumericsTransliterator() throws {
        let data = try loadSimpleJSONData("mathematical-alphanumerics.json")
        try generateSimpleMappingInner(
            className: "MathematicalAlphanumericsTransliterator", mappings: data
        )
    }

    func generateIdeographicAnnotationsTransliterator() throws {
        let data = try loadSimpleJSONData("ideographic-annotation-marks.json")
        try generateSimpleMappingInner(
            className: "IdeographicAnnotationsTransliterator", mappings: data
        )
    }

    struct KanjiVariant: Codable {
        let ivs: [String]?
        let svs: [String]?
    }

    func generateKanjiOldNewTransliterator() throws {
        let data = try loadJSONData("kanji-old-new-form.json", as: [[KanjiVariant]].self)

        var mappings: [(Character, Character)] = []

        for pair in data {
            guard pair.count == 2 else { continue }
            let oldForm = pair[0]
            let newForm = pair[1]

            guard let newIvs = newForm.ivs else { continue }

            if let oldIvs = oldForm.ivs {
                try mappings.append((unicodeTupleToChar(oldIvs), unicodeTupleToChar(newIvs)))
            }

            if let oldSvs = oldForm.svs {
                try mappings.append((unicodeTupleToChar(oldSvs), unicodeTupleToChar(newIvs)))
            }
        }

        let sortedPairs = mappings.sorted { $0.0 < $1.0 }
        try generateSimpleMappingInner(
            className: "KanjiOldNewTransliterator", mappings: sortedPairs
        )
    }
}

// MARK: - Combined Transliterator

extension CodeGenerator {
    func generateCombinedTransliterator() throws {
        let data = try loadJSONData("combined-chars.json", as: [String: String].self)

        var content = fileHeader()
        content += """
        public struct CombinedTransliterator: Transliterator {
            private static let mapping: [Character: String] = [
        """

        let sortedPairs = data.sorted { $0.key < $1.key }
        for (key, value) in sortedPairs {
            let fromChar = try unicodeToChar(key)
            content += "\n        \(escape(fromChar)): \(escape(value)),"
        }

        content += """

            ]

            public init() {}

            public func transliterate<S: Sequence>(_ chars: S) -> [TransliteratorChar] where S.Element == TransliteratorChar {
                var result: [TransliteratorChar] = []
                var offset = 0

                for char in chars {
                    if let charValue = char.value, let replacements = Self.mapping[charValue] {
                        for replacement in replacements {
                            let char = TransliteratorChar(
                                value: replacement,
                                offset: offset,
                                source: char
                            )
                            offset += replacement.utf8.count
                            result.append(char)
                        }
                    } else {
                        let char = char.withOffset(offset)
                        offset += char.utf8Count
                        result.append(char)
                    }
                }

                return result
            }
        }
        """

        try writeFile("CombinedTransliterator.swift", content: content)
        print("Generated CombinedTransliterator.swift")
    }
}

// MARK: - Circled or Squared Transliterator

extension CodeGenerator {
    struct CircledOrSquaredEntry: Decodable {
        let rendering: String
        let type: String
        let isEmoji: Bool

        enum CodingKeys: String, CodingKey {
            case rendering, type, emoji
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            rendering = try container.decode(String.self, forKey: .rendering)
            type = try container.decode(String.self, forKey: .type)

            // Handle both Bool and String for emoji field
            if let boolValue = try? container.decode(Bool.self, forKey: .emoji) {
                isEmoji = boolValue
            } else if let stringValue = try? container.decode(String.self, forKey: .emoji) {
                isEmoji = stringValue == "true"
            } else {
                isEmoji = false
            }
        }
    }

    func generateCircledOrSquaredTransliterator() throws {
        let data = try loadJSONData(
            "circled-or-squared.json", as: [String: CircledOrSquaredEntry].self
        )

        var content = fileHeader()
        content += """
        public struct CircledOrSquaredTransliterator: Transliterator {
            public struct Options {
                public var includeEmojis: Bool = true
                public var circleTemplate: String = "(?)"
                public var squareTemplate: String = "[?]"

                public init() {}
            }

            private struct Entry {
                let rendering: String
                let type: String
                let isEmoji: Bool
            }

            private let options: Options
            private static let mapping: [Character: Entry] = [
        """

        let sortedPairs = data.sorted { $0.key < $1.key }
        for (key, entry) in sortedPairs {
            let fromChar = try unicodeToChar(key)
            content +=
                "\n        \(escape(fromChar)): Entry(rendering: \(escape(entry.rendering)), type: \"\(entry.type)\", isEmoji: \(entry.isEmoji)),"
        }

        content += """

            ]

            public init(options: Options = Options()) {
                self.options = options
            }

            public func transliterate<S: Sequence>(_ chars: S) -> [TransliteratorChar] where S.Element == TransliteratorChar {
                var result: [TransliteratorChar] = []
                var offset = 0

                for char in chars {
                    if let charValue = char.value, let entry = Self.mapping[charValue] {
                        if !options.includeEmojis && entry.isEmoji {
                            result.append(char)
                        } else {
                            let template = entry.type == "circle" ? options.circleTemplate : options.squareTemplate
                            let replacement = template.replacingOccurrences(of: "?", with: entry.rendering)
                            for replacement in replacement {
                                let char = TransliteratorChar(value: replacement, offset: offset, source: char)
                                offset += replacement.utf8.count
                                result.append(char)
                            }
                        }
                    } else {
                        let char = char.withOffset(offset)
                        offset += char.utf8Count
                        result.append(char)
                    }
                }

                return result
            }
        }
        """

        try writeFile("CircledOrSquaredTransliterator.swift", content: content)
        print("Generated CircledOrSquaredTransliterator.swift")
    }
}

// MARK: - IVS/SVS Base Transliterator

extension CodeGenerator {
    struct IvsSvsMapping: Codable {
        let ivs: [String]?
        let svs: [String]?
        let base90: String?
        let base2004: String?
    }

    func generateIvsSvsBaseTransliterator() throws {
        // Generate the binary data file
        let jsonPath = (dataPath as NSString).appendingPathComponent("ivs-svs-base-mappings.json")
        let resourcesPath = (outputPath as NSString).deletingLastPathComponent.appending(
            "/Resources")
        try FileManager.default.createDirectory(
            atPath: resourcesPath, withIntermediateDirectories: true
        )
        let dataPath = (resourcesPath as NSString).appendingPathComponent("ivs_svs_base.data")

        try IvsSvsBaseDataGenerator.generate(from: jsonPath, to: dataPath)

        // Write the transliterator source file (no embedded data)
        // This is already done - the IvsSvsBaseTransliterator.swift now loads from the binary data file
        print("Generated ivs_svs_base.data")
    }
}

// MARK: - Helper Functions

func escape(_ string: String?) -> String {
    guard let string = string else { return "nil" }
    var escaped = String()
    escaped.append("\"")
    for char in string {
        for codepoint in char.unicodeScalars {
            escaped.append(String(format: "\\u{%04X}", codepoint.value))
        }
    }
    escaped.append("\"")
    return escaped
}

func escape(_ char: Character?) -> String {
    guard let char = char else { return escape(nil as String?) }
    return escape(String(char))
}

func unicodeToChar(_ unicode: String) throws -> Character {
    // Handle "U+XXXX" format
    if unicode.hasPrefix("U+") {
        let hex = String(unicode.dropFirst(2))
        if let codePoint = Int(hex, radix: 16),
           let scalar = UnicodeScalar(codePoint)
        {
            return Character(scalar)
        }
    }
    throw CodegenError.invalidUnicodeString("Invalid Unicode format: \(unicode)")
}

func unicodeTupleToString(_ unicodes: [String]) throws -> String {
    // Convert a tuple of Unicode strings to a single Character
    var charValue = String()
    for unicode in unicodes {
        if let char = try? unicodeToChar(unicode) {
            charValue.append(char)
        } else {
            throw CodegenError.invalidUnicodeString("Invalid Unicode string in tuple: \(unicode)")
        }
    }
    return charValue
}

func unicodeTupleToString(_ unicodes: StringOrArray) throws -> String {
    switch unicodes {
    case let .string(value):
        return try String(unicodeToChar(value))
    case let .array(values):
        return try unicodeTupleToString(values)
    }
}

func unicodeTupleToChar(_ unicodes: [String]) throws -> Character {
    return try Character(unicodeTupleToString(unicodes))
}

// MARK: - Main

do {
    let generator = CodeGenerator()
    try generator.run()
} catch {
    print("Error: \(error)")
    exit(1)
}
